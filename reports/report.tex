\documentclass[a4paper,notitlepage]{scrartcl}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{minted}
\usepackage[margin=2cm]{geometry}
\usepackage[final]{pdfpages}
\usepackage{csvsimple}

\newminted[code]{python}{frame=single}

% Use the nicer phi
\let\phi\varphi

\title{Automated Theorem Proving in Python}
\author{Bill Noble\\ Tim van der Molen}
\date{June 2014}

\begin{document}
\maketitle

\section{Introduction}

The use of computer programs to prove logical theorems is called automated
theorem proving. Over time, various proof procedures have been developed. Two
of these are semantic tableaux and resolution. In this report, we shall discuss
these two proof procedures and our implementation of them in the Python
programming language.

\section{Proof Procedures for Propositional Logic}

We shall discuss two proof procedures: resolution and semantic tableaux. They
are so-called refutation systems. That is, to prove a formula $\phi$, the
procedures attempt to refute $\lnot\phi$.

\subsection{Formula Representation}

We use tuples and lists to represent formulas in Python.
As may be expected, tuples in Python are enclosed in round brackets while lists
are enclosed in square brackets.
The elements of a tuple or a list are separated by commas.
For example, \texttt{(a, b, c)} is a tuple and \texttt{[a, b, c]} is a list.
More specifically, a formula representation is recursively defined as follows.

\begin{enumerate}

\item
If \texttt{s} is a string, then \texttt{(s,)} is a formula.

\item
If \texttt{f} is a formula, then \texttt{('not', f)} is a formula.

\item
If \texttt{f} and \texttt{g} are formulas, then \texttt{('arrow', f, g)} is a
formula.

\item
If \texttt{f}$_1$, $\ldots$, \texttt{f}$_n$ are formulas, then \texttt{('and',
[f$_1$, $\ldots$, f$_n$])} is a formula.

\item
If \texttt{f}$_1$, $\ldots$, \texttt{f}$_n$ are formulas, then \texttt{('or',
[f$_1$, $\ldots$, f$_n$])} is a formula.
\end{enumerate}

\noindent
For example, the formula $p \land \lnot q \land (r \to s)$ is represented as
\texttt{('and', [('p',), ('not', ('q',)), ('arrow', ('r',), ('s',))])}.


\subsection{Conjunctive Normal Form}

A formula is in conjunctive normal form (CNF) if it is a conjunction of
subformulas, each of which either is a literal (i.e. an atom or the negation of
an atom) or a disjunction of literals.
As a special case, a CNF formula may consist of only one conjunct, in which
case it simply is either a literal or a disjunction of literals. 
CNF is very useful in automatic theorem proving, because its structure allows
for efficient formula evaluation.
We shall discuss and compare two algorithms to transform arbitrary
propositional formulas into CNF.
The first algorithm employs syntactical manipulation while the second has a
semantic approach relying on truth tables.

\subsubsection{The Syntactic Algorithm}

The syntactic CNF algorithm exploits the distributively of disjunction over
conjunction to transform formulas into CNF.
For example, the non-CNF formula $\phi \lor (\psi \land \chi)$ may be
transformed into the logically equivalent CNF formula $(\phi \lor \psi) \land
(\phi \lor \chi)$ by distributing disjunctions over conjunction.

The syntactic CNF algorithm is applicable only to formulas that are in negation
normal form (NNF).
A formula is in NNF if only atoms are negated and the only other logical
operators that occur in it are disjunction and conjunction.
Therefore, in order for a formula to be transformed into CNF, it first must
have been transformed into NNF.

The NNF algorithm, in turn, is applicable only to formulas in which negation,
disjunction and conjunction occur as the only operators.
Hence, every implicative subformula of the form $\phi \to \psi$ must be
transformed into an equivalent disjunction of the form $\lnot\phi \lor \psi$.
This is done by the impl\_to\_disj() function, which may be defined as follows.

\begin{enumerate}

\item
If $\phi$ is an atom, then $\mathrm{impl\_to\_disj}(\phi) = \phi$.

\item
If $\phi = \lnot\psi$, then $\mathrm{impl\_to\_disj}(\phi) =
\lnot\mathrm{impl\_to\_disj}(\psi)$.

\item
If $\phi = \psi \to \chi$, then $\mathrm{impl\_to\_disj}(\phi) =
\lnot\mathrm{impl\_to\_disj}(\psi) \lor \mathrm{impl\_to\_disj}(\chi)$.

\item
If $\phi = \psi_1 \land \ldots \land \psi_n$, then
$\mathrm{impl\_to\_disj}(\phi) = \mathrm{impl\_to\_disj}(\psi_1) \land \ldots
\land \mathrm{impl\_to\_disj}(\psi_n)$.

\item
If $\phi = \psi_1 \lor \ldots \lor \psi_n$, then
$\mathrm{impl\_to\_disj}(\phi) = \mathrm{impl\_to\_disj}(\psi_1) \lor \ldots
\lor \mathrm{impl\_to\_disj}(\psi_n)$.

\end{enumerate}

\noindent
The Python implementation is as follows.

\begin{code}
def impl_to_disj(f):
    if atom(f):
        return f
    if f[0] == 'not':
        return ('not', impl_to_disj(f[1]))
    if f[0] == 'or' or f[0] == 'and':
        return (f[0], [impl_to_disj(g) for g in f[1]])
    if f[0] == 'arrow':
        return ('or', [('not', impl_to_disj(f[1])), impl_to_disj(f[2])])
    else:
        raise ValueError('unknown operator:', f[0])
\end{code}

\noindent
The atom() function returns true if its tuple argument contains exactly 1
argument and false otherwise:

\begin{code}
def atom(f):
    return len(f) == 1
\end{code}

The nnf() function may be defined as follows.

\begin{enumerate}

\item
If $\phi$ is an atom, then $\mathrm{nnf}(\phi) = \phi$.

\item
If $\phi = \lnot\psi$, then:

\begin{enumerate}

\item
If $\psi$ is an atom, then $\mathrm{nnf}(\phi) = \phi$.

\item
If $\psi = \lnot\chi$, then $\mathrm{nnf}(\phi) = \mathrm{nnf}(\chi)$.

\item
If $\psi = \chi_1 \land \ldots \land \chi_n$, then $\mathrm{nnf}(\phi) =
\mathrm{nnf}(\lnot\chi_1) \lor \ldots \lor \mathrm{nnf}(\lnot\chi_n)$.

\item
If $\psi = \chi_1 \lor \ldots \lor \chi_n$, then $\mathrm{nnf}(\phi) =
\mathrm{nnf}(\lnot\chi_1) \land \ldots \land \mathrm{nnf}(\lnot\chi_n)$.

\end{enumerate}

\item
If $\phi = \psi_1 \land \ldots \land \psi_n$, then $\mathrm{nnf}(\phi) =
\mathrm{nnf}(\psi_1) \land \ldots \land \mathrm{nnf}(\psi_n)$.

\item
If $\phi = \psi_1 \lor \ldots \lor \psi_n$, then $\mathrm{nnf}(\phi) =
\mathrm{nnf}(\psi_1) \lor \ldots \lor \mathrm{nnf}(\psi_n)$.

\end{enumerate}

\noindent
The Python implementation is as follows.

\begin{code}
def nnf(f):
    return nnf_do(impl_to_disj(f))

def nnf_do(f):
    if atom(f):
        return f
    if f[0] == 'not':
        if atom(f[1]):
            return f
        if f[1][0] == 'not':
            return nnf_do(f[1][1])
        if f[1][0] == 'and':
            return ('or', [nnf_do(('not', g)) for g in f[1][1]])
        if f[1][0] == 'or':
            return ('and', [nnf_do(('not', g)) for g in f[1][1]])
        else:
            raise ValueError('unexpected operator:', f[1][0])
    if f[0] == 'and' or f[0] == 'or':
        return (f[0], [nnf_do(g) for g in f[1]])
    else:
        raise ValueError('unexpected operator:', f[0])
\end{code}

The $\mathrm{cnf}()$ function is defined as follows.

\begin{enumerate}

\item
If $\phi$ is a literal, then $\mathrm{cnf}(\phi) = \phi$.

\item
If $\phi = \psi_1 \land \ldots \land \psi_n$, then $\mathrm{cnf}(\phi) =
\mathrm{cnf}(\psi_1) \land \ldots \land \mathrm{cnf}(\psi_n)$.

\item
If $\phi = \psi_1 \lor \ldots \lor \psi_n$, then $\mathrm{cnf}(\phi) =
\mathrm{dist}(\mathrm{cnf}(\psi_1), \mathrm{cnf}(\psi_2 \lor \ldots \lor
\psi_n))$.

\end{enumerate}

\noindent
The $\mathrm{dist}()$ function performs the disjunction distribution and is
defined as follows.

\begin{enumerate}

\item
If $\phi = \chi_1 \land \ldots \land \chi_n$, then $\mathrm{dist}(\phi, \psi) =
\mathrm{dist}(\chi_1, \psi) \land \ldots \land \mathrm{dist}(\chi_n, \psi)$.

\item
If $\psi = \chi_1 \land \ldots \land \chi_n$, then $\mathrm{dist}(\phi, \psi) =
\mathrm{dist}(\phi, \chi_1) \land \ldots \land \mathrm{dist}(\phi, \chi_n)$.

\item
Otherwise, $\mathrm{dist}(\phi, \psi) = \phi \lor \psi$.

\end{enumerate}

\noindent
The algorithm may be described as follows.
It starts at the deepest nested conjunctions and, if necessary, applies the
distribution rule.
This moves the original conjunctions up one level in the formula.
At this level distribution is applied again, if necessary.
This process is continued until all conjunctions have been pushed up above any
disjunction.

The Python implementation of $\mathrm{cnf}()$ and $\mathrm{dist}()$ is as
follows.

\begin{code}
def cnf(f):
    if atom(f) or f[0] == 'not':
        return f
    if f[0] == 'and':
        return ('and', [cnf(g) for g in f[1]])
    if f[0] == 'or':
        if len(f[1]) == 0:
            return f
        if len(f[1]) == 1:
            return cnf(f[1][0])
        else:
            return dist(cnf(f[1][0]), cnf(('or', f[1][1:])))
    else:
        raise ValueError('unknown operator:', f[0])

def dist(f, g):
    if f[0] == 'and':
        if len(f[1]) == 0:
            return f
        else:
            return ('and', [dist(h, g) for h in f[1]])
    if g[0] == 'and':
        if len(g[1]) == 0:
            return g
        else:
            return ('and', [dist(f, h) for h in g[1]])
    else:
        return ('or', [f, g])
\end{code}

After a formula has been transformed into CNF, it may contain nested lists of
conjunctions and disjunctions.
These lists are flattened or collapsed by the flatten() function.
As a final step, the remove\_dups() function removes from every disjunction
list duplicate disjuncts and likewise for the conjunction list.

The Python implementation for these functions is as follows.

\begin{code}
def flatten(f):
    if f[0] == 'and':
        return ('and', flatten_conj(f[1]))
    if f[0] == 'or':
        return ('or', flatten_disj(f[1]))
    else:
        return f

def flatten_conj(flist):
    if flist == []:
        return flist
    if flist[0][0] == 'and':
        return flatten_conj(flist[0][1] + flist[1:])
    else:
        return [flatten(flist[0])] + flatten_conj(flist[1:])

def flatten_disj(flist):
    if flist == []:
        return flist
    if flist[0][0] == 'or':
        return flatten_disj(flist[0][1] + flist[1:])
    else:
        return [flist[0]] + flatten_disj(flist[1:])

def remove_dups(f):
    if f[0] == 'and':
        flist = []
        for g in f[1]:
            g = remove_dups(g)
            if not g in flist:
                flist.append(g)
        return ('and', flist)
    if f[0] == 'or':
        return ('or', list(set(f[1])))
    else:
        return f
\end{code}

\noindent
To incorporate these functions into the function chain, the original cnf()
function is renamed to cnf\_do() and the new cnf() function is as follows.

\begin{code}
def cnf(f):
    return remove_dups(flatten(cnf_do(nnf(f))))
\end{code}

\subsubsection{The Semantic Algorithm}

Rather than converting $f$ to CNF directly, the semantic algorithm
        constructs a truth table and uses it to produce a formula in CNF
        that is logically equivalent to $f$ (i.e. it is true at exactly
        the rows where $f$ is true). 
An analogous and more intuitive strategy exists to produce a formula in
disjunctive normal form (DNF).
For example, suppose one would like to transform the formula
$(p \lor q \to q) \to r$ into DNF.
Consider the truth table of this formula:

\begin{displaymath}
\begin{array}{|c|c|c|c}
   p
 & q
 & r
 & (p\lor{}q)\rightarrow{}r \\
\hline
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 1 \\
0 & 1 & 0 & 0 \\
0 & 1 & 1 & 1 \\
1 & 0 & 0 & 0 \\
1 & 0 & 1 & 1 \\
1 & 1 & 0 & 0 \\
1 & 1 & 1 & 1 \\
\hline
\end{array}
\end{displaymath}

\noindent
To write a formula that is true at exactly one row in a truth table
        (i.e. it is true there and nowhere else), one 
        takes the conjunction of all the atoms or their negations depending
        on their truth or falsity at that row.
For example, the formula $\land [\lnot p, q, r]$ is true at exactly row $4$ in
        the truth table above.
Constructing a DNF formula from a truth table is an extension of this idea:
        just take the disjunction of such formulas for each row where $f$
        is true.
The resulting formula is in DNF and is true at exactly the lines where $f$
        is true (i.e. it is logically equivalent).
Thus we have:
\[
\lor[p,q]\rightarrow r \equiv 
\lor [
\land[\lnot p, \lnot q,\lnot r], 
\land[\lnot p,\lnot q,r], 
\land[\lnot p,q,r], 
\land[p,\lnot q,r], 
\land[p,q,r]
     ]
\]

The Python implementation is as follows.

\begin{code}
# Uses the truth table method to compute disjunctive normal form
def dnf_tt(f):
    # filter the truth table to only rows where f is True
    f_true_tt = [row for row in gen_tt(get_atoms(f)) 
                 if evaluate(f, row) == True]
    # return an 'or' list of 'and' lists (one for each row in
    # f_true_tt) such that each 'and' list contains p when
    # p is True in the row and ('not', p) when it is False.
    return tuple(['or', [tuple(['and', 
        [p if row[p] else tuple(['not', p]) for p in row.keys() ]]) 
        for row in f_true_tt] ])
\end{code}

To construct a CNF formula from the truth table, we take the opposite (but
	obviously
        logically equivalent) approach: the goal is to write a formula
        that is false at exactly the lines where $f$ is false. 
Say we wanted to write a formula that is false at exactly line $3$.
The formula $\land[\lnot p, q, \lnot r]$ is true at exactly line $3$, so its
        negation is false exactly there.
Applying the De Morgan's rule gives $\lor[p, \lnot q, r]$.
Naturally, taking the conjunction of such formulas, we can pick out more rows.
Thus we have:
\[
\lor[p,q]\rightarrow r \equiv 
\land[
\lor[p, \lnot q, r], 
\lor[\lnot p, q, r], 
\lor[\lnot p, \lnot q, r], 
     ]
\]

\begin{code}
# Uses the truth table method to compute conjunctive normal form
def cnf_tt(f):
    # filter the truth table to only rows where f is False 
    f_false_tt = [row for row in gen_tt(get_atoms(f)) 
                  if evaluate(f, row) == False]
    # return an 'and' list of 'or' lists (one for each row in
    # f_false_tt) such that each 'or' list contains ('not', p) when
    # p is True in the row and p when it is False.
    return tuple(['and', [tuple(['or', 
        [p if not row[p] else tuple(['not', p]) for p in row.keys()] ]) 
        for row in f_false_tt]])
\end{code}

\subsubsection{Comparison}

The semantic algorithm has a higher up-front cost than the syntactic one.
The cost of generating the empty truth table is depends on the number of
   atomic propositions since 
it is a list of the $2^n$ possible valuations (where $n$ is the
        number of atomic propositions):
\begin{code}
# Generates all possible valuations for a given set of atoms.     
def gen_tt(atoms):
    from itertools import product
    return [{p:val for (p, val) in zip(atoms, vals)} for vals in 
         product([False, True], repeat=len(atoms))]
\end{code}
Filtering the truth table to only the rows where $f$ is $False$ is rather
        intensive since the formula must be evaluated at each of the
        $2^n$ rows and the evaluation function may be called up to once
        for each subformula of $f$.
Nevertheless, the semantic algorithm performs better on longer random formulas,
	especially 
        where total number of propositions greatly exceeds the total number of
        unique propositions. 

Figure 1 gives the time differences (the execution time of the
syntactic algorithm minus that of the semantic one) when converting 5000 random
formulas to CNF.
The columns represent the number of unique atoms in a formula while the rows
represent the total number of atoms occurring in that formula.

%\csvautotabular{report.csv}

\begin{figure}[!ht]
\caption{Semantic vs. syntactic CNF time differential}
\includegraphics[
    width=\textwidth,
]{report_colors_cropped.pdf}
\end{figure}

For formulas given in DNF, the semantic algorithm is faster for formulas of any
	length,
	and the syntactic algorithm reaches Python's default maximum
	recursion depth 
        of $1000$ beginning at $3$ propositions.

The run time of the syntactic algorithm is agnostic to the number of unique
	propositions
        in the given formula since uniqueness of a proposition is primarily
        semantic notion.
The semantic algorithm is less concerned with the syntactic
        structure of the given formula since this has less bearing on the
        construction of a truth table.
The relative strengths of the two algorithms highlights two distinct ways that
        a propositional formula can be complex.

\subsection{Resolution}
Resolution is a proof method commonly used in automated theorem pr overs.

\subsubsection{Clausal Form}
Before implementing resolution, it is useful to have another way to
   represent propositional formulas.
We shall refer to a list of literals as a \emph{clause}.
A clause is satisfied if any of its literals are satisfied.
Thus a non-empty clause is equivalent to a disjunction of its members.
Note that an empty clause is unsatisfiable.
We shall say that a list of clauses is satisfied if all of clauses in the 
   list are satisfied.
Clearly a list of clauses containing an empty clause is unsatisfiable.
A list of non-empty clauses is equivalent to a formula in CNF.

We define the following utility function for converting a formula in CNF to
   a list of clauses (i.e., a list of lists of literals).
\begin{code}
def fml_to_clauses(f):
    if atom(f) or f[0] == 'not':
        return [[f]]
    if f[0] == 'or': 
        return [f[1]]
    if f[0] == 'and':
        return [fml_to_clauses(x)[0] for x in f[1]]
\end{code}


\subsubsection{The Resolution Rule}
The rule at the core of resolution is as follows:
Given two clauses:
\begin{align*}
A &= [a_1,\ldots,a_{i-1}, p, a_{i},\ldots,a_n]\text{ and }\\
B &= [b_1,\ldots,b_{j-1},\lnot p, b_{j}, \ldots, b_m]
\end{align*}
such that each $a_i$ and $b_i$ are literals and $p$ is an atomic formula,
if $A$ and $B$ are both satisfied, then so 
   is $C = [a_1,..., a_n, b_1..., b_m]$.
Two clauses of the form $A$ and $B$ are called \emph{resolvable}.
We apply the resolution rule to a list of clauses by removing two resolvable
   clauses and replacing them with the result of resolving them.
Repeated application of the resolution rule will result in a list of clauses
   that are pairwise unresolvable.
If $[A_1,...,A_n]$ is a non-empty list of unresolvable clauses, it is easy 
   to see that it is satisfiable, since we may simply choose one literal 
   from each clause to make true, and doing so won't preclude the 
   satisfiability of any of the other clauses.
If any of the clauses is empty then the list is contradictory.
This is natural since the resolution rule can only give an
   empty clause is by resolving two contradictory singleton clauses:
\[
\big[A_1,..., A_{i-1}, [p], [\lnot p], A_i,..., A_n\big] \overset{resolve}\implies
\big[A_1,..., A_{i-1}, [\ ], A_i,..., A_n\big]
\]
Clearly once an empty clause produced, there is no need to resolve further;
   the list is unsatisfiable.

\subsubsection{Implementation}

The deduction theorem for propositional logic says that a sentence $\psi$
   follows from a finite list of sentences $\phi_1,...,\phi_n$ if and only
   if the implication formed by the conjunction of the $\phi_i$'s and $\psi$
   is a tautology:
\[
\phi_1,...,\phi_n\models\psi \iff \models\phi_1\land,...,\land\phi_n
   \rightarrow\psi
\]

A sentence is a tautology if and only if its negation is a contradiction.
The resolution rule can tell us whether a list of clauses is a contradiction.
Thus the problem of checking if $\phi_1,...,\phi_n\models\psi$ is reduced
   to checking whether or not a single sentence is contradictory.

\begin{code}
def resolve_cnf(f):
    return resolve_cnf_do(cnf_to_clauses(cnf(('not', f))))
\end{code}

Thus \texttt{resolve()} shall return \texttt{True} when it finds 
   contradictory clauses and \texttt{False} otherwise.

First we define a function that, given two clauses, returns the result
   of resolving them, or if no resolution is possible, returns 
   \texttt{None} (Python's default return value).

\begin{code}

def resolve_rule(c1, c2):
    for f in c1:
        if f[0] == 'not':
            f_not = f[1]
        else:
            f_not = ('not', f)
        if f_not in c2:
            c1_new = [g for g in c1 if not g == f]
            c2_new = [g for g in c2 if not g == f_not] 
            return c1_new + c2_new
\end{code}

It is also useful to have a couple of utility functions for keeping our
   clauses standardized.
In particular, we don't want to keep any tautologous clauses (those
   a literal and its negation), and we don't want any literal
   appearing more than once in a clause

\begin{code}

def clean_clause(clause):

    if not clause:
        return clause

    clean = []
    for f in clause:
        if ('not', f) in clause:
            return None
        if not f in clean:
            clean.append(f)

    return clean


def clean_clauses(clauses):
    clean_clauses = []
    for clause in clauses:
        clean = clean_clause(clause)
        if clean:
            clean_clauses.append(clean)
    return clean_clauses

\end{code}

Now we are ready to define the resolution algorithm:

\begin{code}

def resolve_cnf_do(clauses):

    from itertools import combinations

    if [] in clauses:
        # We have found an empty clause. 
        return True

    for c1, c2 in combinations(clauses, 2):
        new = clean_clause(resolve_rule(c1, c2))
        if new == None or new in clauses:
            continue
        else:
            clauses.append(new)
            return resolve_cnf_do(clauses)
    
    # There are no new resolutions.
    return False
\end{code}

The \texttt{combinations} allows us to iterate over all the pairs of 
   clauses.
If some pair of clauses resolves to a new clause we have not already
   seen, it is added to the list.
Notice that the resolvants (\texttt{c1} and \texttt{c2}) are not removed
   from the list of clauses when they are used.
This is because clauses must sometimes be re-used consider the following
   proof of $(\lnot p\rightarrow q)\rightarrow ((p\rightarrow q)\rightarrow
   q)$:
\begin{align*}
1.\ & \lnot((\lnot p\rightarrow q)\rightarrow ((p\rightarrow q)\rightarrow q))
   \tag{negated for resolution proof}\\
2.\ & [p, q] \tag{clausal cnf}\\
3.\ & [\lnot p, q] \tag{clausal cnf}\\
4.\ & [\lnot q]  \tag{clausal cnf}\\
5.\ & [p] \tag{resolution rule on 2, 4}\\
6.\ & [\lnot p] \tag{resolution rule on 3, 4}\\
7.\ & [\ ] \tag{resolution rule on 5, 6}
\end{align*}

As you can see, if $4$ were removed from the list of clauses after being
   used toget $5$, it would not be possible to reach the empty clause.

The efficiency of the resolution algorithm diminishes with the length
   of the proof: 
Since the resolvants are not removed, the list of clauses grows with
   each resolution, and it becomes costly to search the pairs.
The algorithm given here is complete, but resolution algorithms for
   predicate logic (which can not be complete anyway)
   use more heuristics when searching for resolvants.

\subsection{Semantic Tableaux}

The semantic tableaux procedure is closely related to disjunctive normal form
(DNF). Analogous to CNF, a formula is in DNF if it is a disjunction of
subformulas, each which either is a literal or a conjunction of literals. As a
special case, a DNF formula may consist of only a single disjunct that is
either a literal or a conjunction of literals. We have implemented a syntactic
DNF algorithm that is symmetric to our implementation of the syntactic CNF
algorithm. Because of this symmetry, we omit the DNF implementation here.

To prove a formula $\phi$, the semantic tableaux procedure begins by taking
$\lnot\phi$ and then repeatedly applying so-called expansion rules to it. These
expansion rules expand $\lnot\phi$ into a tableau or tree with the following
properties. Each node is labeled by a subformula of $\lnot\phi$. Each branch
represents the conjunction of its nodes, while the tree itself represents the
disjunction of its branches. If the expansion is completed, the tree represents
a DNF formula equivalent to $\lnot\phi$.

The expansion rules work as follows. Given a tree, take a branch and a formula
$\psi$ on that branch. Then one of the following rules are applied.

\begin{itemize}
\item
If $\psi$ is of the form $\lnot\lnot\chi$, then add $\chi$ as a new node to the
branch.

\item
If $\psi$ is an alpha (i.e. conjunctive) formula, then add each conjunct of
$\psi$ as a new node to the branch.

\item
If $\psi$ is a beta (i.e. disjunctive) formula, then add each disjunct as a
new child to the last node of the branch.
\end{itemize}

We say that a branch is closed if it contains both a formula and its negation.
A tableau is closed if all of its branches are closed. Thus $\phi$ is proved if
the tableau for $\lnot\phi$ is closed.

\subsubsection{A Simple Semantic Tableaux Implementation}

The approach outlined above suggests a very simple semantic tableaux
implementation. We first call the \texttt{dnf()} function to transform the
formula into DNF. This will provide us with a finished tableau. We then only
have to check if all branches are closed.

\begin{code}
def tableau_dnf(f):
    return tableau_dnf_do(dnf(('not', f)))

def tableau_dnf_do(f):
    if literal(f):
        return False
    if f[0] == 'and':
        return any(atom(g) and ('not', g) in f[1] for g in f[1])
    else:
        return all(tableau_dnf_do(g) for g in f[1])
\end{code}

The drawback of this approach is that it requires the DNF transformation to be
completed before we can check for closure. It would be much more efficient if
we perform closure tests at earlier stages in the DNF transformation. This is
what we will look at now.

\subsubsection{A Better Tableaux Implementation}

Instead of using the \texttt{dnf()} function, we perform the expansion rules
described above. But before applying an expansion rule on a branch, we check if
the branch is closed. If it is, no further expansion of the branch is
necessary. We use the following function to check whether a branch is closed.

\begin{code}
def tableau_closed(branch):
    negations = [f for f in branch if f[0] == 'not']
    for f in negations:
        if f[1] in branch:
            return True
    return False
\end{code}

Now, the expansion rules are applied recursively by the following function. It
takes a single branch as argument, applies one expansion rule to a formula on
the branch and then calls itself with the resulting branch. If the expansion
rule results in multiple branches, it calls itself separately for each branch.

\begin{code}
def tableau_do(branch):
    if tableau_closed(branch):
        return True

    # Handle double negations and alpha formulas.
    for f in branch:
        if f[0] == 'not' and f[1][0] == 'not':
            return tableau_do([g for g in branch if g != f] + [f[1][1]])
        if f[0] == 'and':
            return tableau_do([g for g in branch if g != f] + f[1])
        if (f[0] == 'not' and f[1][0] == 'or'):
            return tableau_do([g for g in branch if g != f] +
                [('not', g) for g in f[1][1]])
        if (f[0] == 'not' and f[1][0] == 'arrow'):
            return tableau_do([g for g in branch if g != f] +
                [f[1][1], ('not', f[1][2])])

    # Handle beta formulas.
    for f in branch:
        if f[0] == 'or':
            return all(tableau_do([h for h in branch if h != f] + [g])
                for g in f[1])
        if f[0] == 'not' and f[1][0] == 'and':
            return all(tableau_do([h for h in branch if h != f] + [('not', g)])
                for g in f[1][1])
        if f[0] == 'arrow':
            return (tableau_do([g for g in branch if g != f] + [('not', f[1])])
                and tableau_do([g for g in branch if g != f] + [f[2]]))

    return False
\end{code}

Finally, the tableaux procedure is initiated by negating the formula to be
proved, putting it on a branch by itself and passing it to
\texttt{tableau\_do()}:

\begin{code}
def tableau(f):
    return tableau_do([('not', f)])
\end{code}

\section{Predicate Methods}

\subsection{Formula Representation}
In propositional logic, atomic formulas are structureless; only their
   names matter.
Thus we were free to represent propositions simply as strings of characters.

In predicate logic, we also want to talk about relations between and functions
   on individuals. 
A \emph{term} refers (rigidly or as a variable) to a single individual.

Formally, terms are defined inductively:
\begin{enumerate}
\item If \texttt{s} is a string beginning with `w', `x', `y' or `z', then
   \texttt{s} is a variable.
A variable is a term.
\item If \texttt{s} is a string beginning with `a', `b', `c', `d', `e', `f' or
   `g', then \texttt{s} is a function symbol.
\item If \texttt{s} is a function symbol then \texttt{(s, [])} is a constant.
A constant is a term.
\item  
If \texttt{s} is a $n$-ary function symbol, and \texttt{[t$_1,\ldots,$t$_n$]} 
   is a list of terms, then \texttt{(s,[t$_1,\ldots,$t$_n$])} is a term.
\end{enumerate}

The functions for determining if a term is a variable, a constant, or a
   function are defined as follows:
\begin{code}
def variable(x):
    return isinstance(x, str) and x[0][0] in 'wxyz'

def function(x):
    return isinstance(x, tuple) and x[0][0] in 'abcdfghj'

def constant(x):
    return function(x) and len(x[1]) == 0 
\end{code}

Predicate logic formulas are defined inductively as follows:
\begin{enumerate}
\item If \texttt{s} is a string beginning with `P', `Q', `R' or `S', and 
   \texttt{[t$_1,\ldots,$t$_n$]} is a list of terms, then \texttt{(s, [t$_1,
      \ldots, $t$_n$])} is an atomic formula.
\item If \texttt{f} is a formula and \texttt{\string{x$_1,\ldots,$x$_n$\string}} is a set of
   variables then:
   \begin{enumerate}
      \item \texttt{('forall', \string{x$_1,\ldots,$x$_n$\string}, f)} is a formula, and
      \item \texttt{('exists', \string{x$_1,\ldots,$x$_n$\string}, f)} is a formula.
   \end{enumerate}

\item
If \texttt{f} is a formula, then \texttt{('not', f)} is a formula.

\item
If \texttt{f} and \texttt{g} are formulas, then \texttt{('arrow', f, g)} is a
formula.

\item
If \texttt{f}$_1$, $\ldots$, \texttt{f}$_n$ are formulas, then \texttt{('and',
[f$_1$, $\ldots$, f$_n$])} is a formula.

\item
If \texttt{f}$_1$, $\ldots$, \texttt{f}$_n$ are formulas, then \texttt{('or',
[f$_1$, $\ldots$, f$_n$])} is a formula.
\end{enumerate}

A variable is \emph{free} in a formula if it appears outside the scope
   of a quantifier.
We call a formula with no free variables a \emph{sentence}.

Two useful functions (with straightforward inductive implementations) are
\begin{code}
def get_free_vars(f, bound_vars):
\end{code}
returning a set containing of all the free variables in \texttt{f} (excluding those
   found in the \texttt{bound\_vars} parameter) and
\begin{code}
def get_funcs(f):
\end{code}
which returns a list of all function symbols (including constants) appearing
   in \texttt{f}.

\subsection{Unification}

A substitution, as we use the term here, is the replacement of a variable by a
term. If $\sigma$ is a substitution and $t$ a term, we write $\sigma t$ to
denote the result of applying $\sigma$ to $t$.

We represent substitutions in Python by dictionaries which essentially are
mappings. Dictionaries in Python are enclosed by curly braces and have
comma-separated elements. Dictionary elements themselves are colon-separated
key-value pairs.

A substitution may be applied to a list of terms (such as the arguments of a
predicate or function). Additionally, substitutions may be composed. We use the
following functions for these purposes.

\begin{code}
def subst_termlist(subst, termlist):
    return [subst_term(subst, t) for t in termlist]

def subst_term(subst, term):
    if variable(term):
        return subst[term] if term in subst else term
    else:
        return (term[0], subst_termlist(subst, term[1]))

def compose_subst(s1, s2):
    comp = {}
    comp.update(s1)
    comp.update({t:subst_term(s1, s2[t]) for t in s2})
    return comp
\end{code}

A unification algorithm is an algorithm that searches for a substitution that
makes two lists of terms equal. That is, given two lists $(t_1, \ldots, t_n)$
and $(u_1, \ldots, u_n$) of terms, a unification algorithm searches for a
substitution $\sigma$ such that $(\sigma t_1, \ldots, \sigma t_n) = (\sigma
u_1, \ldots, \sigma u_n)$. Unification will be used in the tableaux proof
procedure for predicate logic that we will discuss later.

Our unification implementation is as follows. It uses the built-in
\texttt{zip()} function, which works as follows. Given two lists $(a_1, \ldots,
a_n)$ and $(b_1, \ldots, b_n)$, \texttt{zip()} returns essentially a list
$(c_1, \ldots, c_n)$ such that $c_i = (a_i, b_i)$.

\begin{code}
def unify_termlists(t1, t2):
    if len(t1) == len(t2) == 0:
        return {}
    if len(t1) != len(t2):
        return None
    else:
        subst = {}
        for (u1, u2) in zip(t1, t2):
            v1 = subst_term(subst, u1)
            v2 = subst_term(subst, u2)
            newsubst = unify_terms(v1, v2)
            if newsubst == None:
                return None
            subst = compose_subst(newsubst, subst)
        return subst

def unify_terms(t1, t2):
    if variable(t1) and variable(t2):
        if t1 == t2:
            return {}
        else:
            return {t1:t2}
    if variable(t1) and not variable(t2):
        if t1 in variables_in_term(t2):
            return None
        else:
            return {t1:t2}
    if not variable(t1) and variable(t2):
        if t2 in variables_in_term(t1):
            return None
        else:
            return {t2:t1}
    else:
        if t1[0] != t2[0]:
            return None
        else:
            return unify_termlists(t1[1], t2[1])

def variables_in_term(term):
    if variable(term):
        return {term}
    else:
        var = set()
        for t in term[1]:
            var |= variables_in_term(t)
        return var
\end{code}

\subsection{Skolemization}
In this section we write $\phi(x_1,...,x_n)$ to emphasize that $\phi$ is
   a formula with free variables $x_1,...,x_n$.

A formula with free variables is satisfiable if every sentence resulting
   from an assignment of those free variables is satisfiable.
Thus $\phi(x_1,...,x_n)$ is satisfiable if and only if $\forall x_1,...,
   x_n\phi(x_1,...x_n)$ is satisfiable.
Consider the formula $\exists y \phi(x, y)$ where $x$ is free and $y$
   is bound by $\exists$.
This formula is equivalent to $\forall x\exists y\phi(x, y)$.
Suppose that it is satisfiable in some model.
In that model it must be that for every $x$, there is a $y$ such 
   that $\phi(x,y)$ holds.
In other words, $\phi$ defines a function from $x$ to $y$ in the model's
   domain.
But if that is true, then there is an extension of that model where
   that function is given an explicit interpretation.
Skolemization is the process of introducing a new function in the formula
   that stands for that formula.
Thus $\exists y\phi(x, y)$ is satisfiable if and only
   if $\phi(x, f(x))$ is satisfiable for some function $f$ not appearing
   in $\phi$.

More generally, if $f_1,...,f_n$ do not appear in $\phi$ then
\begin{align*}
\exists y_1,...,y_n\phi(x_1,...,x_m, y_1,...,y_n)
   &\equiv \phi(x_1,...,x_n, f_1(x_1,...,x_m),...,f_n(x_1,...,x_m))\text{ and}\\
\lnot\forall y_1,...,y_n\phi(x_1,...,x_m, y_1,...,y_n)
   &\equiv \lnot \phi(x_1,...,x_n, f_1(x_1,...,x_m),...,f_n(x_1,...,x_m)).
\end{align*}

By using this Skolemization technique on formulas of one of the
   forms above, we reduce the cases new in the predicate satisfaction
   problem to formulas beginning with $\forall$ and $\lnot\exists$. 

The following Python takes the formula in the scope of the 
   existential quantifier (\texttt{f}) and the variables that it ranges
   over (\texttt{exists\_vars}), and returns the skolemized formula.
The parameter \texttt{func\_counter} can be used to keep track of Skolem 
   functions that have already been used.

\begin{code}
def tableau_skolemize(f, exists_vars, func_counter):
    free_vars = get_free_vars(f, exists_vars)
    used_funcs = get_funcs(f)

    g = f
    for v in exists_vars:
        while 'f' + str(func_counter) in used_funcs:
            func_counter += 1
        skolem_func = 'f' + str(func_counter)
        used_funcs.append(skolem_func)
        g = subst_formula({v:(skolem_func, list(free_vars))}, g)
    return (g, func_counter + 1)
\end{code}

\subsection{Tableaux}

In the case of predicate logic, two new rules are added to handle quantifiers.

\begin{itemize}
\item
If $\psi$ is a delta (i.e. existential) formula, then replace it with its
skolemization.

\item
If $\psi$ is a gamma (i.e. universal) formula, then add to the branch a copy of
$\psi$ in which a the universally quantified variable has been replaced with a
free variable that does not occur elsewhere in the tree. Thus, if $\psi =
\forall x_1, \ldots, x_n \chi(x_1, \ldots, x_n)$, then add $\chi(y_1, \ldots,
y_n)$ where $y_1, \ldots, y_n$ are new free variables.
\end{itemize}

In order for a branch to close, it has to contain both a formula $P$ and $\lnot
P$. Obviously, this is the case if we have $P(x1, \ldots, x_n)$ and $\lnot
P(x1, \ldots, x_n)$. However, if we have $P(x1, \ldots, x_n)$ and $\lnot P(y_1,
\ldots, y_n)$, we need to apply unification to the terms of $P$ and $\lnot P$.
Since we would like to close the whole tree, we need to choose unifications
that not just close a single branch, but also are compatible with the
unifications needed to close other branches.

In some tableau proofs, it necessary to unify a variable not only with one
other term, but with two or more. For this reason, it may be necessary to apply
the gamma rule to a formula more than once. Unfortunately, given the
undecidability of first-order logic, often it is not known in advance how often
the gamma rule should be applied. An implementation of a first-order tableaux
proof procedure therefore needs to limit the number of gamma rule applications.
This limit should be specified along with the formula to be proved. In our
implementation, this limit is called \texttt{gdepth}.

We use the \texttt{tableau\_canonize()} function to transform formulas into a
canonical type. That is, alpha formulas are transformed into formulas with
$\land$ as their main operator, gamma formulas are transformed such that
$\forall$ is their main operator and so forth. To determine the type of a
formula, this allows us simply to determine its main operator. The
implementation of the function is as follows.

\begin{code}
def tableau_canonize(f):

    # Handle double negations.
    if f[0] == 'not' and f[1][0] == 'not':
        return tableau_canonize(f[1][1])

    # Handle alpha formulas.
    if f[0] == 'and':
        return f 
    if f[0] == 'not' and f[1][0] == 'or':
        return ('and', [('not', g) for g in f[1][1]])
    if f[0] == 'not' and f[1][0] == 'arrow':
        return ('and', [f[1][1], ('not', f[1][2])])

    # Handle beta formulas.
    if f[0] == 'or':
        return f 
    if f[0] == 'not' and f[1][0] == 'and':
        return ('or', [('not', g) for g in f[1][1]])
    if f[0] == 'arrow':
        return ('or', [('not', f[1]), f[2]])

    # Handle delta formulas.
    if f[0] == 'exists':
        return f 
    if f[0] == 'not' and f[1][0] == 'all':
        return ('exists', f[1][1], ('not', f[1][2]))

    # Handle gamma formulas.
    if f[0] == 'all':
        return f
    if f[0] == 'not' and f[1][0] == 'exists':
        return ('all', f[1][1], ('not', f[1][2]))

    # Handle literals. 
    else:
        return f 
\end{code}

The beginning of our implementation, then, is as follows.

\begin{code}
def tableau(f, gdepth):
    tree = tableau_expand(f, gdepth)
    return tableau_closed(tree)

def tableau_expand(f, gdepth):
    branch = [tableau_canonize(('not', f))]
    return tableau_expand_do([branch], gdepth, 0, 0)
\end{code}

The real work is done by \texttt{tableau\_expand\_do()}. This function takes
the full tableau as a list of branches, the `gdepth', a counter for the Skolem
functions and a counter for the free variables. These two counters are used to
ensure newly introduced Skolem functions and free variables are unique.

\begin{code}
def tableau_expand_do(tree, gdepth, skolem_func_counter, uni_var_counter):
    if tree == []:
        return tree

    # Handle alpha formulas.
    for f in tree[0]:
        if f[0] == 'and':
            tree[0].remove(f)
            tree[0].extend([tableau_canonize(g) for g in f[1]])
            return tableau_expand_do(tree, gdepth, skolem_func_counter, \
		uni_var_counter)

    # Handle beta formulas.
    for f in tree[0]:
        if f[0] == 'or':
            branch = tree[0]
            tree.remove(branch)
            branch.remove(f)
            for sub in [tableau_canonize(g) for g in f[1]]:
                # Inserting is more expensive than appending, but it is helpful
                # for debugging.
                tree.insert(0, branch + [sub])
            return tableau_expand_do(tree, gdepth, skolem_func_counter, \
		uni_var_counter)

    # Handle delta formulas.
    for f in tree[0]:
        if f[0] == 'exists':
            g, skolem_func_counter = tableau_skolemize(f[2], f[1], \
		skolem_func_counter)
            tree[0].remove(f)
            tree[0].append(tableau_canonize(g))
            return tableau_expand_do(tree, gdepth, skolem_func_counter, \
		uni_var_counter)

    # Handle gamma formulas.
    for f in tree[0]:
        if f[0] == 'all':
            tree[0].remove(f)
            if gdepth > 0:
                tree[0].append(f)
                gdepth -= 1
            new_f = f[2]
            for var in f[1]:
                parameter = 'x' + str(uni_var_counter)
                uni_var_counter += 1
                new_f = subst_formula({var:parameter}, new_f)
            tree[0].append(tableau_canonize(new_f))
            return tableau_expand_do(tree, gdepth, skolem_func_counter, \
		uni_var_counter)

    return tableau_expand_do(tree[1:], gdepth, skolem_func_counter, \
	uni_var_counter) + [tree[0]]
\end{code}

This function expands all branches in the tableau by repeated application of
the expansion rules. Gamma rules are applied until a `gdepth' of 0 has been
reached. If the tableau expansion is complete, the algorithm moves to the
closure stage. In this stage we visit all branches of the tree, and try to
close each of them, taking into account all substitutions from previous branch
closures.

\begin{code}
def tableau_closed(tree):
    substs = {}
    for branch in tree:
        newsubsts = tableau_branch_closed(branch, substs)
        if newsubsts == None:
            return False
        substs = compose_subst(newsubsts, substs)
    return True

def tableau_branch_closed(branch, substs):
    positives = [f for f in branch if pred(f)]
    negatives = [f for f in branch if f[0] == 'not']

    for f in positives:
        for g in negatives:
            if f[0] == g[1][0]:
                f_terms = subst_termlist(substs, f[1])
                g_terms = subst_termlist(substs, g[1][1])
                newsubsts = unify_termlists(f_terms, g_terms)
                if newsubsts != None:
                    return newsubsts
    return None
\end{code}

\subsubsection{Example Proof}

To demonstrate the predicate tableaux algorithm we shall walk through the
   proof that relations which are serial, symmetric, and transitive are
   necessarily reflexive.

Let $R$ be a first-order binary relation. 
We will use the following abbreviations:
\begin{align*}
\textsf{serial}& \iff \forall x\exists yRxy\\
\textsf{symmetric}& \iff \forall xy(Rxy\rightarrow Ryx)\\
\textsf{transtive}& \iff \forall xyz((Rxy\land Ryz)\rightarrow Rxz)\\
\textsf{reflexive}& \iff \forall x Rxx
\end{align*}

Informally, it is easy to see why this must be the case.
Suppose we have model where $R$ is serial, symmetric, and transitive.
We assume non-empty domain, so let $a$ be given.
By seriality, there is an element $b$ such that $Rab$.
By symmetry, we have $Rba$ as well.
From transitivity, and $Rab$ and $Rba$, we have $Raa$.
Thus $Rxx$ must hold for all $x$; $R$ is reflexive.

The tableaux proof is quite a bit longer, but the shadow of this same 
   reasoning is present in it.
The algorithm can do this proof with a single instantiation of each 
   universal statement, so \texttt{gdepth} is set to $1$.
To start with we give the algorithm the following formula:
\[
\textsf{serial}\land\textsf{symmetric}\land\textsf{transitive}
   \rightarrow\textsf{reflexive}
\]
Which is converted to a tableau containing a single branch with that 
   formula's negation:
\[
[[\lnot(\textsf{serial}\land\textsf{symmetric}\land\textsf{transitive}
   \rightarrow\textsf{reflexive})]]
\]

From here we give the debug messages from \texttt{tableau\_expand\_do}.

After applying the alpha rule twice we have:
\begin{verbatim}
branch 1:
   Ex~R(x, x)
   AxEyR(x, y)
   Axy(R(x, y) -> R(y, x))
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
\end{verbatim}

The   delta rule (Skolemization) is applied to \texttt{Ex~R(x, x)}:
\begin{verbatim}
branch 1:
   AxEyR(x, y)
   Axy(R(x, y) -> R(y, x))
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
   ~R(f0, f0)
\end{verbatim}

The delta rule is applied to \texttt{EyR(x0, y)}:
\begin{verbatim}
branch 1:
   Axy(R(x, y) -> R(y, x))
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
   ~R(f0, f0)
   AxEyR(x, y)
   EyR(x0, y)
\end{verbatim}

The delta rule is applied to the newly-aded \texttt{EyR(x0, y)}:

\begin{verbatim}
branch 1:
   Axy(R(x, y) -> R(y, x))
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
   ~R(f0, f0)
   AxEyR(x, y)
   R(x0, f1(x0))
\end{verbatim}

The gamma rule is applied to \texttt{Axy(R(x, y) -> R(y, x))}:
\begin{verbatim}
branch 1:
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
   ~R(f0, f0)
   AxEyR(x, y)
   R(x0, f1(x0))
   ~R(x1, x2) V R(x2, x1)
\end{verbatim}

The beta rule is applied to \texttt{~R(x1, x2) V R(x2, x1)}.

\begin{verbatim}
branch 1:
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
   ~R(f0, f0)
   AxEyR(x, y)
   R(x0, f1(x0))
   ~R(x2, x1)

branch 2:
   Azxy((R(x, y) & R(y, z)) -> R(x, z))
   ~R(f0, f0)
   AxEyR(x, y)
   R(x0, f1(x0))
   R(x1, x2)
\end{verbatim}

After being fully expanded there are six branches:

\begin{minipage}[t]{.3\textwidth}
\begin{verbatim}
branch 1:
   ~R(f0, f0)
   R(x0, f1(x0))
   ~R(x2, x1)
   R(x5, x3)
   R(x9, f2(x9))

branch 4:
   ~R(f0, f0)
   R(x0, f1(x0))
   ~R(x2, x1)
   ~R(x4, x3)
   R(x12, f5(x12))
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{.3\textwidth}
\begin{verbatim}
branch 2:
   ~R(f0, f0)
   R(x0, f1(x0))
   R(x1, x2)
   R(x8, x6)
   R(x10, f3(x10))

branch 5:
   ~R(f0, f0)
   R(x0, f1(x0))
   R(x1, x2)
   ~R(x8, x7)
   R(x13, f6(x13))
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{.3\textwidth}
\begin{verbatim}
branch 3:
   ~R(f0, f0)
   R(x0, f1(x0))
   ~R(x2, x1)
   ~R(x5, x4)
   R(x11, f4(x11))

branch 6:
   ~R(f0, f0)
   R(x0, f1(x0))
   R(x1, x2)
   ~R(x7, x6)
   R(x14, f7(x14))

\end{verbatim}

\end{minipage}
\hfill\  \\

Now we move to the closure stage.
Recall that the goal is to find an assignment of the free variables 
   into terms such that each branch contains a literal and its dual.
The closure algorithm iterates through each branch, finding unifications
   which will close it.
The unification map is cumulatively composed as each branch is closed.
Below are the substitutions added at each branch that close each branch
   and the cumulative substitution that results.

\begin{verbatim}
Branch 1:
New substitutions: {x0 -> x2, x1 -> f1(x2)}
Cumulative:        {x0 -> x2, x1 -> f1(x2)}

Branch 2:
New substitutions: {x8 -> f0, x6 -> f0}
Cumulative:        {x8 -> f0, x1 -> f1(x2), x6 -> f0, x0 -> x2}

Branch 3:
New substitutions: None
Cumulative:        {x8 -> f0, x1 -> f1(x2), x6 -> f0, x0 -> x2}

Branch 4:
New substitutions: None
Cumulative:        {x8 -> f0, x1 -> f1(x2), x6 -> f0, x0 -> x2}

Branch 5:
New substitutions: {x2 -> f0, x7 -> f1(f0)}
Cumulative:        {x8 -> f0, x2 -> f0, x0 -> f0, x1 -> f1(f0), x6 -> f0, x7 -> f1(f0)}

Branch 6:
New substitutions: None
Cumulative:        {x8 -> f0, x2 -> f0, x0 -> f0, x1 -> f1(f0), x6 -> f0, x7 -> f1(f0)}

\end{verbatim}

Below are the results of applying cumulative substitutions to each
   branch (up the the substitution added to close it).
Closure pairs are marked with a \texttt{*}.

Notice that as we go there are fewer and fewer variables left to assign.
Here we are able to close the tableau by the end, but even tautological
   formluas may result in a tableau tha can not be closed if the gdepth
   provided to \texttt{tableau\_expand} is insufficient.

\begin{minipage}[t]{.3\textwidth}
\begin{verbatim}

branch 1:
   ~R(f0, f0)
 * R(x2, f1(x0))
 * ~R(x2, f1(x2))
   R(x5, x3)
   R(x9, f2(x9))

branch 4:
   ~R(f0, f0)
 * R(x2, f1(x2))
 * ~R(x2, f1(x2))
   ~R(x4, x3)
   R(x12, f5(x12))
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{.3\textwidth}
\begin{verbatim}

branch 2:
 * ~R(f0, f0)
   R(x2, f1(x0))
   R(f1(x2), x2)
 * R(f0, f0)
   R(x10, f3(x10))

branch 5:
   ~R(f0, f0)
 * R(f0, f1(f0))
   R(f1(f0), f0)
 * ~R(f0, f1(f0))
   R(x13, f6(x13))
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{.3\textwidth}
\begin{verbatim}

branch 3:
   ~R(f0, f0)
 * R(x2, f1(x2))
 * ~R(x2, f1(x2))
   ~R(x5, x4)
   R(x11, f4(x11))

branch 6:
   ~R(f0, f0)
   R(f0, f1(f0))
 * R(f1(f0), f0)
 * ~R(f1(f0), f0)
   R(x14, f7(x14))

\end{verbatim}

\end{minipage}
\hfill\  \\
Since each branch is closed, we may conclude that the expanded tableau
   is unsatisfiable, thus the formula provided to \texttt{tableau} is
   a tautology.


\end{document}
